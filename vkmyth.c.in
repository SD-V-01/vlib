////////////////////////////////////////////////////////////////////////////
//
//  VLib Source File.
//  Copyright (C) 2024 S/N: V-01
// -------------------------------------------------------------------------
//  File name:   vkmyth.c
//  Version:     v1.00
//  Created:     29/07/24 by V.
//  Description: 
// -------------------------------------------------------------------------
//  This project is licensed under the MIT License
//
////////////////////////////////////////////////////////////////////////////

#include "vkmyth.h"
#include "mdos.h"

#ifdef __APPLE__
#error Dont even think about it, the apple vision pro is a misstake

#endif

#ifdef __cplusplus
extern "C"{
#endif

static mdsoHandle Libvk = mdsoNullHandle;
static VkDevice MainDevice = VK_NULL_HANDLE;

static PFN_vkVoidFunction mythVkNullifyInstanceFuncPtr(VkInstance Instance, const char* Name){
	(void)Instance;
	(void)Name;
	return NULL;

}

static PFN_vkVoidFunction mythVkNullifyDeviceFuncPtr(VkDevice Device, const char* Name){
	(void)Device;
	(void)Name;
	return NULL;

}


VkResult mythVkLoad(){
	mdsoHandle Handle = mdsoOpen(MYTH_VK_LOAD_DLL, mdsoFlags_localSymbols);
	if(!Handle){
		Handle = mdsoOpen(MYTH_VK_LOAD_DLL_BACKUP, mdsoFlags_localSymbols);

	}

	if(!Handle){
		VERRNF("VkLoader", "Could not load vulkan api");
		return VK_ERROR_INITIALIZATION_FAILED;

	}

	vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)mdsoGetFunc(Handle, "vkGetInstanceProcAddr");
	Libvk = Handle;
	_mythVkLoadBasic(NULL, vkGetInstanceProcAddr);

	return VK_SUCCESS;

}

void mythVkExit(){
	if(Libvk){
		mdsoClose(Libvk);

	}

	vkGetInstanceProcAddr = NULL;
	_mythVkLoadBasic(NULL, &mythVkNullifyInstanceFuncPtr);
	_mythVkLoadInstance(NULL, &mythVkNullifyInstanceFuncPtr);
	_mythVkLoadDevice(NULL, &mythVkNullifyDeviceFuncPtr);
	MainDevice = VK_NULL_HANDLE;

}

uint32_t mythVkGetInstanceVer(){
	#if defined(VK_VERSION_1_1)
	uint32_t Ver = 0;
	if(vkEnumerateInstanceVersion && vkEnumerateInstanceVersion(&Ver) == VK_SUCCESS){
		return Ver;

	}
	#endif

	if(vkCreateInstance){
		return VK_API_VERSION_1_0;

	}

	return 0;

}

void mythVkLoadInstance(VkInstance Instance){
	_mythVkLoadInstance(Instance, vkGetInstanceProcAddr);

}

void mythVkLoadDevice(VkDevice Device){
	MainDevice = Device;
	_mythVkLoadDevice(Device, vkGetDeviceProcAddr);

}

void mythVkLoadArrayDevice(mythVkDeviceFuncArray* FuncArray, VkDevice Device){
	_mythVkLoadArrayDevice(FuncArray, Device, vkGetDeviceProcAddr);

}

void _mythVkLoadBasic(VkInstance Instance, PFN_vkGetInstanceProcAddr LoadFunc){

//SECTION(V): VK_LOADER_BASIC_IMPL

}

MYTH_VK_LOAD_API void _mythVkLoadInstance(VkInstance Instance, PFN_vkGetInstanceProcAddr LoadFunc){

//SECTION(V): VK_LOADER_INSTANCE_IMPL

}

void _mythVkLoadDevice(VkDevice Device, PFN_vkGetDeviceProcAddr LoadFunc){

//SECTION(V): VK_LOADER_DEVICE_IMPL

}

void _mythVkLoadArrayDevice(mythVkDeviceFuncArray* FuncArray, VkDevice Device, PFN_vkGetDeviceProcAddr LoadFunc){

//SECTION(V): VK_LOADER_DEVICE_ARRAY_IMPL

}

//SECTION(V): VK_PROTOTYPES_IMPL

#ifdef __cplusplus
}
#endif
